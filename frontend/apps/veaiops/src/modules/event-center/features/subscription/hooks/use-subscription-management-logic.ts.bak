// Copyright 2025 Beijing Volcano Engine Technology Co., Ltd. and/or its affiliates
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import apiClient from '@/utils/api-client';
import { Button, Form, Message } from '@arco-design/web-react';
import { IconPlus } from '@arco-design/web-react/icon';
import { API_RESPONSE_CODE } from '@veaiops/constants';
import { useManagementRefresh } from '@veaiops/hooks';
import { createTableRequestWrapper, logger } from '@veaiops/utils';
import type {
  AttributeItem,
  SubscribeRelationCreate,
  SubscribeRelationUpdate,
  SubscribeRelationWithAttributes,
} from 'api-generate';
import { StatusCodes } from 'http-status-codes';
import React, { useState, useCallback, useMemo } from 'react';

/**
 * è®¢é˜…å…³ç³»è¡¨æ ¼æ•°æ®ç±»å‹
 */
export interface SubscriptionTableData extends SubscribeRelationWithAttributes {
  key: string;
  [key: string]: any; // æ·»åŠ ç´¢å¼•ç­¾åä»¥æ»¡è¶³ BaseRecord çº¦æŸ
}

/**
 * è½¬æ¢è®¢é˜…å…³ç³»æ•°æ®ä¸ºè¡¨æ ¼æ•°æ®
 */
const transformSubscriptionToTableData = (
  subscription: any,
): SubscriptionTableData => {
  return {
    ...subscription,
    id: subscription.id || `temp-${Date.now()}-${Math.random()}`,
    key: subscription.id || `temp-${Date.now()}-${Math.random()}`,
    name: subscription.name || 'æœªå‘½åè®¢é˜…å…³ç³»',
    agent_type: subscription.agent_type,
    inform_strategy_ids: subscription.inform_strategy_ids || [],
    event_level: subscription.event_level,
    start_time: subscription.start_time,
    end_time: subscription.end_time,
    created_at: subscription.created_at || new Date().toISOString(),
    updated_at: subscription.updated_at || new Date().toISOString(),
    attributes: subscription.attributes || [],
    interest_products: subscription.interest_products || [],
    interest_projects: subscription.interest_projects || [],
    interest_customers: subscription.interest_customers || [],
    enable_webhook: subscription.enable_webhook,
    webhook_endpoint: subscription.webhook_endpoint,
    webhook_headers: subscription.webhook_headers,
  };
};

/**
 * è®¢é˜…ç®¡ç†é€»è¾‘Hook
 * æä¾›è®¢é˜…ç®¡ç†é¡µé¢çš„æ‰€æœ‰ä¸šåŠ¡é€»è¾‘
 */
export const useSubscriptionManagementLogic = (
  refreshTable?: () => Promise<void>,
) => {
  // ä½¿ç”¨ç®¡ç†åˆ·æ–° Hook
  const { afterCreate, afterUpdate, afterDelete } =
    useManagementRefresh(refreshTable);
  const [form] = Form.useForm();
  const [editingSubscription, setEditingSubscription] =
    useState<SubscribeRelationWithAttributes | null>(null);
  const [modalVisible, setModalVisible] = useState(false);

  /**
   * åˆ›å»ºè®¢é˜…å…³ç³»
   */
  const createSubscription = useCallback(
    async (subscriptionData: SubscribeRelationCreate): Promise<boolean> => {
      try {
        const response =
          await apiClient.subscribe.postApisV1ManagerEventCenterSubscribe({
            requestBody: subscriptionData,
          });

        if (response.code === API_RESPONSE_CODE.SUCCESS && response.data) {
          Message.success('äº‹ä»¶è®¢é˜…åˆ›å»ºæˆåŠŸ');
          return true;
        } else {
          throw new Error(response.message || 'åˆ›å»ºè®¢é˜…å…³ç³»å¤±è´¥');
        }
      } catch (error) {
        Message.error(
          error instanceof Error ? error.message : 'åˆ›å»ºè®¢é˜…å…³ç³»å¤±è´¥',
        );
        return false;
      }
    },
    [],
  );

  /**
   *æ›´æ–°è®¢é˜…å…³ç³»
   */
  const updateSubscription = useCallback(
    async (
      subscriptionId: string,
      updateData: SubscribeRelationUpdate,
    ): Promise<boolean> => {
      try {
        const response =
          await apiClient.subscribe.putApisV1ManagerEventCenterSubscribe({
            uid: subscriptionId,
            requestBody: updateData,
          });

        if (response.code === API_RESPONSE_CODE.SUCCESS && response.data) {
          Message.success('è®¢é˜…æ›´æ–°æˆåŠŸ');
          return true;
        }

        throw new Error(response.message || 'æ›´æ–°è®¢é˜…å…³ç³»å¤±è´¥');
      } catch (error) {
        Message.error(
          error instanceof Error ? error.message : 'æ›´æ–°è®¢é˜…å…³ç³»å¤±è´¥',
        );
        return false;
      }
    },
    [],
  );

  /**
   *åˆ é™¤è®¢é˜…å…³ç³»
   */
  const deleteSubscription = useCallback(
    async (subscriptionId: string): Promise<boolean> => {
      try {
        const response =
          await apiClient.subscribe.deleteApisV1ManagerEventCenterSubscribe({
            uid: subscriptionId,
          });

        if (response.code === API_RESPONSE_CODE.SUCCESS) {
          Message.success('è®¢é˜…å…³ç³»åˆ é™¤æˆåŠŸ');
          return true;
        }

        throw new Error(response.message || 'åˆ é™¤è®¢é˜…å…³ç³»å¤±è´¥');
      } catch (error) {
        Message.error(
          error instanceof Error ? error.message : 'åˆ é™¤è®¢é˜…å…³ç³»å¤±è´¥',
        );
        return false;
      }
    },
    [],
  );

  // åˆ é™¤è®¢é˜…å…³ç³»å¤„ç†å™¨
  const handleDelete = useCallback(
    async (subscriptionId: string) => {
      try {
        const success = await deleteSubscription(subscriptionId);
        if (success) {
          // åˆ é™¤æˆåŠŸååˆ·æ–°è¡¨æ ¼
          await afterDelete();
          return true;
        }
        return false;
      } catch (error) {
        Message.error('åˆ é™¤å¤±è´¥ï¼Œè¯·é‡è¯•');
        return false;
      }
    },
    [deleteSubscription, afterDelete],
  );

  // åˆ›å»ºè®¢é˜…å…³ç³»å¤„ç†å™¨
  const handleCreate = useCallback(
    async (values: SubscribeRelationCreate) => {
      try {
        const success = await createSubscription(values);
        if (success) {
          setModalVisible(false);
          form.resetFields();
          // åˆ›å»ºæˆåŠŸååˆ·æ–°è¡¨æ ¼
          await afterCreate();
          return true;
        }
        return false;
      } catch (error) {
        Message.error('åˆ›å»ºå¤±è´¥ï¼Œè¯·é‡è¯•');
        return false;
      }
    },
    [createSubscription, form, afterCreate],
  );

  // æ›´æ–°è®¢é˜…å…³ç³»å¤„ç†å™¨
  const handleUpdate = useCallback(
    async (values: SubscribeRelationUpdate) => {
      try {
        const success = await updateSubscription(
          editingSubscription?._id || '',
          values,
        );
        if (success) {
          setModalVisible(false);
          setEditingSubscription(null);
          form.resetFields();
          // æ›´æ–°æˆåŠŸååˆ·æ–°è¡¨æ ¼
          await afterUpdate();
          return true;
        }
        return false;
      } catch (error) {
        Message.error('æ›´æ–°å¤±è´¥ï¼Œè¯·é‡è¯•');
        return false;
      }
    },
    [editingSubscription, updateSubscription, form, afterUpdate],
  );

  // å¤„ç†è¡¨å•æäº¤
  const handleSubmit = useCallback(
    async (
      values: SubscribeRelationCreate | SubscribeRelationUpdate,
    ): Promise<boolean> => {
      const success = editingSubscription
        ? await handleUpdate(values as SubscribeRelationUpdate)
        : await handleCreate(values as SubscribeRelationCreate);

      if (!success) {
        // é˜»æ­¢å¼¹çª—åœ¨å¤±è´¥æ—¶è‡ªåŠ¨å…³é—­
        throw new Error('Operation failed but error message was displayed.');
      }
      return success;
    },
    [editingSubscription, handleUpdate, handleCreate],
  );

  // æ‰“å¼€ç¼–è¾‘å¼¹çª—
  const handleEdit = useCallback(
    (subscription: SubscribeRelationWithAttributes) => {
      setEditingSubscription(subscription);
      form.setFieldsValue({
        ...subscription,
      });
      setModalVisible(true);
    },
    [form],
  );

  // æ‰“å¼€æ–°å¢å¼¹çª—
  const handleAdd = useCallback(() => {
    setEditingSubscription(null);
    form.resetFields();
    setModalVisible(true);
  }, [form]);

  // å…³é—­å¼¹çª—
  const handleCancel = useCallback(() => {
    setModalVisible(false);
    setEditingSubscription(null);
    form.resetFields();
  }, [form]);

  return {
    // çŠ¶æ€
    modalVisible,
    editingSubscription,
    form,

    // äº‹ä»¶å¤„ç†å™¨
    handleEdit,
    handleAdd,
    handleCancel,
    handleSubmit,
    handleDelete,
  };
};

/**
 * è®¢é˜…å…³ç³»è¡¨æ ¼é…ç½®Hook
 * æä¾›æ•°æ®æºé…ç½®ç­‰ï¼ˆåˆ—é…ç½®å·²ç§»è‡³ç»„ä»¶ä¸­å¤„ç†ï¼‰
 */
export const useSubscriptionTableConfig = ({
  handleEdit: _handleEdit,
  handleDelete: _handleDelete,
}: {
  handleEdit: (subscription: SubscribeRelationWithAttributes) => void;
  handleDelete: (subscriptionId: string) => Promise<boolean>;
}) => {
  // ğŸ” Hook æ‰§è¡Œè®¡æ•°ï¼ˆç”¨äºè°ƒè¯•ï¼‰
  const hookExecutionRef = React.useRef(0);
  hookExecutionRef.current++;

  logger.debug({
    message: '[useSubscriptionTableConfig] Hook æ‰§è¡Œ',
    data: {
      executionCount: hookExecutionRef.current,
      handleEditRef: _handleEdit,
      handleDeleteRef: _handleDelete,
    },
    source: 'useSubscriptionTableConfig',
    component: 'useSubscriptionTableConfig',
  });

  /**
   * CustomTableçš„requestå‡½æ•°
   * ğŸ”§ ä½¿ç”¨ useMemo ç¨³å®šåŒ–å‡½æ•°å¼•ç”¨ï¼Œé¿å…è§¦å‘ä¸å¿…è¦çš„è¡¨æ ¼åˆ·æ–°
   * ç›´æ¥è°ƒç”¨APIè·å–æ•°æ®
   */
  const request = useMemo(
    () => {
      logger.debug({
        message: '[useSubscriptionTableConfig] request å‡½æ•°åˆ›å»º',
        data: {
          executionCount: hookExecutionRef.current,
        },
        source: 'useSubscriptionTableConfig',
        component: 'useMemo',
      });

      return createTableRequestWrapper({
        apiCall: async (params: Record<string, any>) => {
          try {
            const response =
              await apiClient.subscribe.getApisV1ManagerEventCenterSubscribe({
                skip: params.skip || 0,
                limit: params.limit || 10,
                ...params,
              });

            if (response.code === API_RESPONSE_CODE.SUCCESS && response.data) {
              const tableData = response.data.map(
                transformSubscriptionToTableData,
              );
              return {
                data: tableData,
                total: (response as any).total ?? tableData.length,
              };
            } else {
              throw new Error(response.message || 'è·å–è®¢é˜…å…³ç³»åˆ—è¡¨å¤±è´¥');
            }
          } catch (error) {
            Message.error('åŠ è½½è®¢é˜…å…³ç³»åˆ—è¡¨å¤±è´¥ï¼Œè¯·é‡è¯•');
            return {
              data: [],
              total: 0,
            };
          }
        },
        defaultLimit: 10,
      });
    },
    [], // request å‡½æ•°ä¸ä¾èµ–ä»»ä½•å¤–éƒ¨å˜é‡ï¼Œä½¿ç”¨ç©ºä¾èµ–æ•°ç»„
  );

  // ğŸ”§ ä½¿ç”¨ useMemo ç¨³å®šåŒ– dataSource å¯¹è±¡å¼•ç”¨ï¼Œé¿å…è§¦å‘ä¸å¿…è¦çš„è¡¨æ ¼åˆ·æ–°
  const dataSource = useMemo(() => {
    logger.debug({
      message: '[useSubscriptionTableConfig] dataSource å¯¹è±¡åˆ›å»º',
      data: {
        executionCount: hookExecutionRef.current,
        requestRef: request,
      },
      source: 'useSubscriptionTableConfig',
      component: 'useMemo',
    });

    return {
      request,
      ready: true,
      isServerPagination: true,
    };
  }, [request]);

  // ğŸ”§ ä½¿ç”¨ useMemo ç¨³å®šåŒ– tableProps å¯¹è±¡å¼•ç”¨
  const tableProps = useMemo(
    () => ({
      rowKey: '_id',
      scroll: { x: 2000 },
      pagination: {
        pageSize: 10,
        showTotal: (total: number) => `å…± ${total} æ¡è®°å½•`,
        showJumper: true,
        sizeCanChange: true,
        sizeOptions: [10, 20, 50, 100],
      },
    }),
    [],
  );

  return {
    dataSource,
    tableProps,
  };
};

/**
 * è®¢é˜…å…³ç³»æ“ä½œæŒ‰é’®é…ç½®Hook
 * æä¾›è¡¨æ ¼å·¥å…·æ æ“ä½œæŒ‰é’®é…ç½®
 */
export const useSubscriptionActionConfig = (onAdd: () => void) => {
  const actions = [
    React.createElement(
      Button,
      {
        key: 'add',
        type: 'primary',
        icon: React.createElement(IconPlus),
        onClick: onAdd,
      },
      'æ–°å»ºè®¢é˜…',
    ),
  ];

  return { actions };
};
